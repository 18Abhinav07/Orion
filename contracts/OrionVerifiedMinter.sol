// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Interface for the Story Protocol RegistrationWorkflows contract
interface IRegistrationWorkflows {
    function mintAndRegisterIp(
        address spgNftContract,
        address recipient,
        IPMetadata calldata ipMetadata
    ) external returns (address ipId, uint256 tokenId);
}

struct IPMetadata {
    string ipMetadataURI;
    bytes32 ipMetadataHash;
    string nftMetadataURI;
    bytes32 nftMetadataHash;
}

/**
 * @title OrionVerifiedMinter
 * @dev This contract acts as a wrapper for Story Protocol's RegistrationWorkflows.
 * It verifies a backend-generated signature before allowing a mint to proceed.
 * This ensures that only users authorized by the Orion backend can mint IP assets.
 */
contract OrionVerifiedMinter {
    address public immutable BACKEND_VERIFIER_ADDRESS;
    address public REGISTRATION_WORKFLOWS;
    address public SPG_NFT_CONTRACT;
    address public owner;

    mapping(uint256 => bool) public usedNonces;

    event IpAssetMinted(
        address indexed recipient,
        address indexed ipId,
        uint256 indexed tokenId,
        address signer
    );

    event ContractsUpdated(address indexed registrationWorkflows, address indexed spgContract);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    /**
     * @param _backendVerifier The address of the backend service authorized to sign minting requests.
     * @param _registrationWorkflows The Story Protocol RegistrationWorkflows contract address.
     */
    constructor(address _backendVerifier, address _registrationWorkflows) {
        require(_backendVerifier != address(0), "Backend verifier address cannot be zero");
        require(_registrationWorkflows != address(0), "RegistrationWorkflows address cannot be zero");
        BACKEND_VERIFIER_ADDRESS = _backendVerifier;
        REGISTRATION_WORKFLOWS = _registrationWorkflows;
        owner = msg.sender;
    }

    /**
     * @notice Sets or updates the SPG-NFT contract address. Can only be called by the owner.
     * @param _spgNftContract The new address for the SPG-NFT contract.
     */
    function setSpgNftContract(address _spgNftContract) external onlyOwner {
        require(_spgNftContract != address(0), "SPG NFT contract address cannot be zero");
        SPG_NFT_CONTRACT = _spgNftContract;
        emit ContractsUpdated(REGISTRATION_WORKFLOWS, _spgNftContract);
    }

    /**
     * @notice Verifies a signature and mints an IP asset if the signature is valid.
     * @param recipient The address that will receive the minted NFT.
     * @param contentHash A unique hash representing the content of the IP.
     * @param ipMetadataURI The URI for the IP's metadata.
     * @param nftMetadataURI The URI for the NFT's metadata (this will be passed to the SPG contract).
     * @param nonce A unique number to prevent replay attacks.
     * @param expiryTimestamp A timestamp after which the signature is no longer valid.
     * @param signature The ECDSA signature generated by the backend.
     * @return ipId The ID of the registered IP asset.
     * @return tokenId The ID of the minted NFT.
     */
    function verifyAndMint(
        address recipient,
        bytes32 contentHash,
        string memory ipMetadataURI,
        string memory nftMetadataURI,
        uint256 nonce,
        uint256 expiryTimestamp,
        bytes memory signature
    ) external returns (address ipId, uint256 tokenId) {
        require(SPG_NFT_CONTRACT != address(0), "SPG contract address not set");
        require(block.timestamp <= expiryTimestamp, "Token expired");
        require(!usedNonces[nonce], "Nonce already used");

        bytes32 messageHash = _hashMessage(
            recipient,
            contentHash,
            ipMetadataURI,
            nftMetadataURI,
            nonce,
            expiryTimestamp
        );
        
        address signer = _recoverSigner(messageHash, signature);
        require(signer == BACKEND_VERIFIER_ADDRESS, "Invalid signature");

        usedNonces[nonce] = true;

        // Call RegistrationWorkflows.mintAndRegisterIp instead of SPG directly
        IPMetadata memory ipMetadata = IPMetadata({
            ipMetadataURI: ipMetadataURI,
            ipMetadataHash: keccak256(bytes(ipMetadataURI)),
            nftMetadataURI: nftMetadataURI,
            nftMetadataHash: keccak256(bytes(nftMetadataURI))
        });

        (ipId, tokenId) = IRegistrationWorkflows(REGISTRATION_WORKFLOWS).mintAndRegisterIp(
            SPG_NFT_CONTRACT,
            recipient,
            ipMetadata
        );

        emit IpAssetMinted(recipient, ipId, tokenId, signer);

        return (ipId, tokenId);
    }

    /**
     * @dev Hashes the minting parameters to create a unique message for signing.
     */
    function _hashMessage(
        address recipient,
        bytes32 contentHash,
        string memory ipMetadataURI,
        string memory nftMetadataURI,
        uint256 nonce,
        uint256 expiryTimestamp
    ) internal pure returns (bytes32) {
        return keccak256(
            abi.encodePacked(
                recipient,
                contentHash,
                keccak256(bytes(ipMetadataURI)),
                keccak256(bytes(nftMetadataURI)),
                nonce,
                expiryTimestamp
            )
        );
    }

    /**
     * @dev Recovers the address of the signer from a message hash and signature.
     */
    function _recoverSigner(
        bytes32 messageHash,
        bytes memory signature
    ) internal pure returns (address) {
        bytes32 prefixedHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
        );
        (bytes32 r, bytes32 s, uint8 v) = _splitSignature(signature);
        return ecrecover(prefixedHash, v, r, s);
    }

    /**
     * @dev Splits a signature into its r, s, and v components.
     */
    function _splitSignature(
        bytes memory signature
    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(signature.length == 65, "Invalid signature length");
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
    }
}
